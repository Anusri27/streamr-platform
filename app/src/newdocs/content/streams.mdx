import ScrollableAnchor from 'react-scrollable-anchor'
import { Link } from 'react-router-dom'

import docsStyles from '$newdocs/components/DocsLayout/docsLayout.pcss'
import links from '$shared/../links'
import CodeSnippet from '$shared/components/CodeSnippet'

import {
    CreateJavascriptClient,
    CreateJavaClient,
    AuthJavascriptClient,
    AuthJavaClient,
    SubscribeJavascriptClient,
    SubscribeJavaClient,
    PublishJavascriptClient,
    PublishJavaClient,
} from './code/streams.js'

<ScrollableAnchor id="intro-to-streams"><div>

## Intro to streams
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="work-with-streams-in-core"><div>

## Work with streams in Core
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="work-with-streams-via-sdks"><div>

## Work with streams via SDKs

The easiest way to work with streams is to use the JavaScript client, which works in `node.js` as well as the browser. See the <Link to={links.newdocs.SDKs}>SDKs section</Link> for the official and community-maintained client libraries available for various languages:

- **JavaScript** client works in the browser as well as node.js.
- **Java** client is work-in-progress but already implements the most important set of functionality.

Client libraries for other languages are on the <a href={links.community.trello} target="_blank" rel="nofollow noopener noreferrer">roadmap</a>. If a client library isn't available for your language, you can dive into the details of the [websocket protocol](https://github.com/streamr-dev/streamr-client-protocol-js/blob/bb2f0168bcff454b5c458e275e9c2de0dee342f9/PROTOCOL.md).

If you'd like to contribute a client library and get it listed here, please get in touch on <a href={links.community.telegram} target="_blank" rel="nofollow noopener noreferrer">Telegram</a>, <a href={links.community.reddit} target="_blank" rel="nofollow noopener noreferrer">Reddit</a> or <a href={links.contact.general} rel="nofollow noopener noreferrer">email</a>!

### Authentication

When reading from or writing to Streams, you need to provide a session token or an API key, or login with an Ethereum account. To read more about API keys or obtaining a session token, refer to the <Link to={links.newdocs.api}>Authentication section of the API documentation</Link>.

### Creating a client instance with API key

**Javascript**

<CodeSnippet language='javascript'>{CreateJavascriptClient}</CodeSnippet>

**Java**

<CodeSnippet language='java'>{CreateJavaClient}</CodeSnippet>

### Subscribing to real-time events in a stream

By subscribing to Streams, your application gets immediately notified about new events in the Stream. 

**JavaScript**

<CodeSnippet language='javascript'>{SubscribeJavascriptClient}</CodeSnippet>

**Java**

<CodeSnippet language='java'>{SubscribeJavaClient}</CodeSnippet>

### Publishing events to Streams

JavaScript:

<CodeSnippet language='javascript'>{PublishJavascriptClient}</CodeSnippet>

Java:

Events in Streams are key-value pairs, represented in Java as Map objects. Below is an example of creating an event payload and publishing it into a Stream:

<CodeSnippet language='java'>{PublishJavaClient}</CodeSnippet>

</div></ScrollableAnchor>

<ScrollableAnchor id="work-with-streams-via-api"><div>

## Work with streams via API
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="data-signing-and-verification"><div>

## Data signing and verification

Authenticity and integrity of events published on a stream can be guaranteed with digital signatures. Every stream's metadata has a boolean `requiresSignedData` that can be set by the stream's owner to let subscribers know whether they should expect signed or unsigned events.

Every message published to a stream has six fields that uniquely identify this message across time, all streams and all publishers:

- `streamId`
- `streamPartititon`
- `timestamp`
- `sequenceNumber`
- `publisherId`
- `msgChainId`

More details about these fields can be found in the [protocol specification](TODO: insert link once merged). All together they form the message ID. They must be signed along with the actual message `content` to resist against replay attacks.

So the payload to be signed for every message by every publisher is the following:

```
payload = streamId + streamPartition + timestamp + sequenceNumber + publisherId + msgChaindId + content
```

The signing algorithm follows the convention described [here](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md). The secp256k1 ECDSA algorithm is applied on the keccak256 hash of a string derived from the challenge text:

```
signature = sign(keccak256("\x19Ethereum Signed Message:\\n" + len(payload) + payload)))
```

On the recipient side, every subscriber needs to verify signed events. If a received event is unsigned, the subscriber accepts the event if and only if the stream's boolean flag `requiresSignedData` is set to `false`.

The signature verification is done in three steps:

1. the subscriber extracts from the event and the signature the Ethereum address that signed the message (using the EC recover operation).
2. Check that the address recovered in step 1 matches the address defined by `publisherId`
3. Check that this `publisherId` belongs to the set of valid publishers for that stream by querying the `api/v1/streams/${id}/publishers` endpoint.

Both signature computation and verification are implemented in the Javascript and Java SDKs.

</div></ScrollableAnchor>

<ScrollableAnchor id="end-to-end-encryption"><div>

## End-to-end encryption
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="partitioning"><div>

## Partitioning
--content--

</div></ScrollableAnchor>
