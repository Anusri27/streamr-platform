# End-to-end encryption

Confidentiality of events published on a stream can be guaranteed with end-to-end encryption. The publisher decides on a AES-256 symmetric group key and encrypts the messages in CTR mode before publishing them to the network. The subscribers must know this symmetric group key in order to decrypt the data.

There are two ways for the subscribers to obtain that symmetric group key: either the publisher shares the key with the subscribers in a secure way outside of the Streamr Network, or the subscribers use a secure key-exchange protocol to request the symmetric group key to the publisher using the Streamr Network.

In the first case, in both the <a href="https://github.com/streamr-dev/streamr-client-javascript" target="_blank">Javascript</a> and the <a href="https://github.com/streamr-dev/streamr-client-java" target="_blank">Java</a> SDKs, the publisher can pass group keys per stream as parameters and the subscriber can pass group keys per stream and per publisher as parameters.

In the case of the key-exchange mechanism, all publishers and subscribers are required to be identified by an Ethereum account to sign exchanged messages. This avoids the risk of Man-in-the-Middle attacks. Every subscriber also needs to have an RSA public-private key pair to encrypt and decrypt symmetric group keys. In both the <a href="https://github.com/streamr-dev/streamr-client-javascript" target="_blank">Javascript</a> and the <a href="https://github.com/streamr-dev/streamr-client-java" target="_blank">Java</a> SDKs, this RSA key pair can be passed to the client instance or automatically generated.
When a subscriber wants to obtain the symmetric group key from a publisher, it sends a "group key request" containing the RSA public key signed by its Ethereum private key to the publisher through the Streamr Network. Upon reception of such a request, after verification of its validity, the publisher encrypts the symmetric group key using the subscriber's RSA public key and sends the encrypted group key back to the subscriber in a signed "group key response" through the Streamr Network. The subscriber can decrypt the received symmetric group key using its RSA private key. The following pseudocode shows the workflow of the key-exchange protocol:

```
Publisher p >> k = gen_AES_key()
Subscriber s >> (RSA_pub, RSA_priv) = gen_RSA_key_pair()
Subscriber s >> group_key_request = (RSA_pub, sign(RSA_pub, s_eth_private_key))
Subscriber s >> send(p, group_key_request)
Publisher p >> c = RSA_encrypt(k, group_key_request.RSA_pub)
Publisher p >> group_key_response = (c, sign(c, p_eth_private_key))
Publisher p >> send(s, group_key_response)
Subscriber s >> k = RSA_decrypt(group_key_response.c, RSA_priv)
```

In order to prevent new subscribers to eavesdrop and then decrypt past messages published before the start of their subscription, the publisher can decide at any time to update the symmetric group key by sending a new key concatenated with an event and encrypted with the current key:
```
// normal case when creating a ciphertext of an event 'm1' with a key 'k1'
c1 = AES_encrypt(m1, k1)
// when updating the key to 'k2', current subscribers will recover 'k2'
c2 = AES_encrypt(m2 + k2, k1)
// the next messages can be encrypted with 'k2', new subscribers obtain 'k2' but not 'k1' so they cannot decrypt m1 and m2
c3 = AES_encrypt(m3, k2)
```

Both the Javascript and the Java SDKs support this key update mechanism. It can be triggered by calling the `publish` method with a new symmetric group key as parameter.